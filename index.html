<!doctype html>
<html lang="en-AU">
    <head>
        <title>GLTF Animation Blending</title>
        <meta
            name="description"
            content="A basic demonstration of loading and applying Mixamo
        animations as separate GLTF files in Three.js.
        Includes basic blending, skeleton, and speed controls."
        />

        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="mobile-web-app-capable" content="yes" />
        <meta name="theme-color" content="#000" />
        <meta name="author" content="Henry Egloff" />

        <link rel="icon" type="image/x-icon" href="favicon.svg" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap"
            rel="stylesheet"
        />

        <style>
            * {
                font-family: "Roboto Mono", monospace;
                font-weight: 350;
            }

            html {
                min-height: 100%;
                display: flex;
                flex-direction: column;
            }

            body {
                margin: 0;
                flex-grow: 1;
                overflow: hidden;
                line-height: 1.5;
                text-align: center;
                background: linear-gradient(155deg, #000 20%, #222);
                color: #fff;
            }

            #threejs-canvas {
                opacity: 0;
                transition: opacity 2s;
            }

            [loaded] #threejs-canvas {
                opacity: 1;
            }
        </style>

        <link rel="stylesheet" href="./_css/loader.css" />
        <link rel="stylesheet" href="./_css/fullscreen-button.css" />
        <link rel="stylesheet" href="./_css/range-slider.css" />
        <link rel="stylesheet" href="./_css/input-buttons.css" />
        <link rel="stylesheet" href="./_css/controls.css" />
    </head>

    <body>
        <div id="threejs-canvas" class="screen"></div>

        <div id="loader">
            <div class="cube-animation">
                <div class="cube">
                    <div class="front"><span></span></div>
                    <div class="back"><span></span></div>
                    <div class="top"><span></span></div>
                    <div class="bottom"><span></span></div>
                    <div class="left"><span></span></div>
                    <div class="right"><span></span></div>
                </div>
            </div>
            <p>{ loading }</p>
        </div>

        <script>
            setTimeout(() => {
                if (!document.body.hasAttribute("loaded")) {
                    document.body.setAttribute("loading", "");
                }
            }, 1000);
        </script>

        <div id="controls">
            <label for="animation-speed-slider">
                Speed: <span id="animation-speed-value">1</span>
            </label>

            <div class="range-slider-container">
                <div class="range-track"></div>
                <div
                    id="range-slider-1-track-highlight"
                    class="range-track track-highlight"
                ></div>
                <input
                    type="range"
                    min="0"
                    max="100"
                    value="100"
                    class="slider"
                    id="animation-speed-slider"
                />
            </div>

            <hr />

            <label class="custom-input-button"
                >Skeleton
                <input type="checkbox" id="skeleton-button" />
                <span class="checkmark"></span>
            </label>

            <hr />

            <label class="custom-input-button"
                >Idle
                <input
                    type="radio"
                    id="animation-button-1"
                    name="animation"
                    checked="checked"
                />
                <span class="radio-button"></span>
            </label>

            <br />

            <label class="custom-input-button"
                >Look
                <input type="radio" id="animation-button-2" name="animation" />
                <span class="radio-button"></span>
            </label>

            <br />

            <label class="custom-input-button"
                >Dance
                <input type="radio" id="animation-button-3" name="animation" />
                <span class="radio-button"></span>
            </label>

            <br />

            <label class="custom-input-button"
                >Bored
                <input type="radio" id="animation-button-4" name="animation" />
                <span class="radio-button"></span>
            </label>
        </div>

        <!-- Import maps polyfill -->
        <!-- Remove this when import maps will be widely supported -->
        <script
            async
            src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
        ></script>

        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.139.0/build/three.module.js"
                }
            }
        </script>

        <script type="module">
            import * as THREE from "three";
            import { OrbitControls } from "https://unpkg.com/three@0.139.0/examples/jsm/controls/OrbitControls.js";
            import { GLTFLoader } from "https://unpkg.com/three@0.139.0/examples/jsm/loaders/GLTFLoader.js";

            let scene, camera, renderer, controls;

            let clock, speed, skeleton;
            let actions = [];
            let action_1, action_2, action_3, action_4;
            let currentAction, newAction;

            const mixers = [];
            let mixer;

            init();

            function init() {
                clock = new THREE.Clock();

                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera(
                    25,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000,
                );
                camera.position.set(0, 1.5, -6);

                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true,
                });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.setAnimationLoop(animation);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.target = new THREE.Vector3(0, 1, 0);
                controls.enableDamping = true;
                controls.maxPolarAngle = Math.PI * 0.5 + 0.01; // limit vertical
                controls.minDistance = 2;
                controls.maxDistance = 12;

                let threejs_canvas = document.getElementById("threejs-canvas");
                threejs_canvas.appendChild(renderer.domElement);

                // Grid Helper

                const gridHelper = new THREE.GridHelper(
                    20,
                    20,
                    0x080808,
                    0x080808,
                );
                scene.add(gridHelper);

                // Directional Light

                const directional_light = new THREE.DirectionalLight(
                    0xffffff,
                    0.7,
                );
                directional_light.position.set(2, 6, -2);
                directional_light.castShadow = true;
                directional_light.shadow.camera.near = 0.1;
                directional_light.shadow.camera.far = 10;
                directional_light.shadow.mapSize.width = 2048;
                directional_light.shadow.mapSize.height = 2048;
                scene.add(directional_light);

                // Hemisphere Light

                const hemisphere_light = new THREE.HemisphereLight(
                    0xffffff,
                    0x000000,
                    0.4,
                );
                hemisphere_light.position.set(-4, 6, 8);
                scene.add(hemisphere_light);

                // Hemisphere Light

                const hemisphere_light_2 = new THREE.HemisphereLight(
                    0xffffff,
                    0x000000,
                    0.4,
                );
                hemisphere_light_2.position.set(-6, 2, -8);
                scene.add(hemisphere_light_2);

                // Materials

                const shadow_material = new THREE.ShadowMaterial({
                    opacity: 0.15,
                });

                // Ground Plane

                const ground_geometry = new THREE.PlaneGeometry(20, 20);
                const ground_mesh = new THREE.Mesh(
                    ground_geometry,
                    shadow_material,
                );
                ground_mesh.receiveShadow = true;
                ground_mesh.rotateX(-Math.PI / 2);
                scene.add(ground_mesh);

                // Load GLTF

                const gltf_loader = new GLTFLoader();

                gltf_loader.load(
                    "../_models/robot-idle.glb",
                    function (gltf) {
                        console.log("Robot model with idle animation loaded");

                        const model = gltf.scene;
                        model.rotation.y = Math.PI;
                        mixer = new THREE.AnimationMixer(model);
                        mixers.push(mixer);

                        gltf.scene.traverse((node) => {
                            if (node.isMesh) node.frustumCulled = false;
                            if (node.isMesh) node.castShadow = true;
                        });

                        action_1 = mixer.clipAction(gltf.animations[0]);
                        actions.push(action_1);
                        action_1.play();
                        currentAction = mixer.clipAction(gltf.animations[0]);

                        skeleton = new THREE.SkeletonHelper(model);
                        skeleton.visible = false;

                        scene.add(skeleton);
                        scene.add(model);

                        load_animations();
                    },
                    function (xhr) {
                        console.log(
                            (xhr.loaded / xhr.total) * 100 + "% loaded",
                        );
                    },
                    function (error) {
                        console.log("Error loading file");
                    },
                );

                function load_animations() {
                    gltf_loader.load(
                        "../_models/look-around.glb",
                        function (gltf) {
                            console.log("Look Around animation loaded");

                            action_2 = mixer.clipAction(gltf.animations[0]);
                            actions.push(action_2);
                        },
                        function (xhr) {
                            console.log(
                                (xhr.loaded / xhr.total) * 100 + "% loaded",
                            );
                        },
                        function (error) {
                            console.log("Error loading file");
                        },
                    );

                    gltf_loader.load(
                        "../_models/gangnam-style.glb",
                        function (gltf) {
                            console.log("Gangnam Style animation loaded");

                            action_3 = mixer.clipAction(gltf.animations[0]);
                            actions.push(action_3);
                        },
                        function (xhr) {
                            console.log(
                                (xhr.loaded / xhr.total) * 100 + "% loaded",
                            );
                        },
                        function (error) {
                            console.log("Error loading file");
                        },
                    );

                    gltf_loader.load(
                        "../_models/yawn.glb",
                        function (gltf) {
                            console.log("Yawn animation loaded");
                            action_4 = mixer.clipAction(gltf.animations[0]);
                            actions.push(action_4);
                        },
                        function (xhr) {
                            console.log(
                                (xhr.loaded / xhr.total) * 100 + "% loaded",
                            );
                        },
                        function (error) {
                            console.log("Error loading file");
                        },
                    );

                    ui_timer();
                    document.body.removeAttribute("loading");
                    document.body.setAttribute("loaded", "");
                }

                activateAllActions();
            }

            function animation(time) {
                const delta = clock.getDelta();
                for (const mixer of mixers) mixer.update(delta);

                controls.update();
                renderer.render(scene, camera);
            }

            function activateAllActions() {
                actions.forEach(function (action) {
                    action.play();
                });
            }

            function switchAction() {
                if (newAction != currentAction) {
                    currentAction.fadeOut(0.3);
                    newAction.reset();
                    newAction.setEffectiveWeight(1);
                    newAction.play();
                    newAction.fadeIn(0.3);
                    currentAction = newAction;
                }
            }

            // Toggle Skeleton

            const skeleton_button = document.getElementById("skeleton-button");
            skeleton_button.addEventListener("click", function (e) {
                if (skeleton.visible == false) {
                    skeleton.visible = true;
                } else {
                    skeleton.visible = false;
                }
            });

            // Animation Speed Slider

            const animation_speed_slider = document.getElementById(
                "animation-speed-slider",
            );
            update_slider();

            animation_speed_slider.addEventListener("input", function (e) {
                update_slider();
            });

            function update_slider() {
                let slider_value = animation_speed_slider.value / 100;
                let slider_width = animation_speed_slider.offsetWidth;
                let slider_value_element = document.getElementById(
                    "animation-speed-value",
                );
                let slider_track_highlight = document.getElementById(
                    "range-slider-1-track-highlight",
                );

                slider_track_highlight.style.width =
                    slider_width * slider_value + "px";
                slider_value_element.innerHTML = slider_value;

                for (const mixer of mixers) {
                    mixer.timeScale = slider_value;
                }
            }

            // Animation Buttons

            const animation_button_1 =
                document.getElementById("animation-button-1");
            animation_button_1.addEventListener("click", function () {
                newAction = action_1;
                switchAction();
            });

            const animation_button_2 =
                document.getElementById("animation-button-2");
            animation_button_2.addEventListener("click", function () {
                newAction = action_2;
                switchAction();
            });

            const animation_button_3 =
                document.getElementById("animation-button-3");
            animation_button_3.addEventListener("click", function () {
                newAction = action_3;
                switchAction();
            });

            const animation_button_4 =
                document.getElementById("animation-button-4");
            animation_button_4.addEventListener("click", function () {
                newAction = action_4;
                switchAction();
            });

            // Window Resize

            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // UI Timer

            const ui_timer = function () {
                let time;
                document.onmousemove = resetTimer;
                document.ontouchmove = resetTimer;
                document.onkeydown = resetTimer;

                function timeout() {
                    document.body.removeAttribute("ui");
                }

                function resetTimer() {
                    clearTimeout(time);
                    document.body.setAttribute("ui", "");
                    time = setTimeout(timeout, 3000);
                }
            };

            // Fullscreen button

            if (
                document.fullscreenEnabled ||
                document.webkitFullscreenEnabled ||
                document.msFullscreenEnabled
            ) {
                create_fullscreen_button();
            }

            function create_fullscreen_button() {
                let fullscreen_button = document.createElement("button");
                fullscreen_button.setAttribute("id", "fullscreen-button");
                fullscreen_button.addEventListener("click", toggle_fullscreen);

                fullscreen_button.innerHTML = `
                <span></span>
                <span></span>
                <span></span>
                <span></span>
            `;

                document.body.appendChild(fullscreen_button);
            }

            function toggle_fullscreen() {
                if (
                    !document.fullscreenElement &&
                    !document.mozFullScreenElement &&
                    !document.webkitFullscreenElement
                ) {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen();
                    } else if (document.documentElement.mozRequestFullScreen) {
                        document.documentElement.mozRequestFullScreen();
                    } else if (
                        document.documentElement.webkitRequestFullscreen
                    ) {
                        document.documentElement.webkitRequestFullscreen(
                            Element.ALLOW_KEYBOARD_INPUT,
                        );
                    }

                    document.body.setAttribute("fullscreen", "");
                } else {
                    if (document.cancelFullScreen) {
                        document.cancelFullScreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitCancelFullScreen) {
                        document.webkitCancelFullScreen();
                    }

                    document.body.removeAttribute("fullscreen");
                }
            }

            function check_fullscreen() {
                // (Because users can exit / enter fullscreen via device / browser)

                if (document.fullscreenElement !== null) {
                    document.body.setAttribute("fullscreen", "");
                } else {
                    document.body.removeAttribute("fullscreen");
                }
            }

            setInterval(function () {
                check_fullscreen();
            }, 1000);
        </script>
    </body>
</html>
